package org.javarosa.j2me.storage.rms;

import org.javarosa.core.log.LogEntry;
import org.javarosa.core.log.WrappedException;
import org.javarosa.core.model.utils.DateUtils;
import org.javarosa.core.services.Logger;
import org.javarosa.core.services.storage.EntityFilter;
import org.javarosa.core.services.storage.IStorageIterator;
import org.javarosa.core.services.storage.IStorageUtility;
import org.javarosa.core.services.storage.Persistable;
import org.javarosa.core.services.storage.StorageFullException;
import org.javarosa.core.util.externalizable.CannotCreateObjectException;
import org.javarosa.core.util.externalizable.ExtUtil;
import org.javarosa.core.util.externalizable.ExtWrapMap;
import org.javarosa.core.util.externalizable.Externalizable;
import org.javarosa.core.util.externalizable.PrototypeFactory;
import org.javarosa.j2me.log.StatusReportException;
import org.javarosa.j2me.log.XmlStatusProvider;
import org.javarosa.j2me.storage.rms.raw.RMS;
import org.javarosa.j2me.storage.rms.raw.RMSFactory;
import org.xmlpull.v1.XmlSerializer;

import java.io.IOException;
import java.util.Enumeration;
import java.util.Hashtable;
import java.util.Vector;

import javax.microedition.rms.RecordEnumeration;
import javax.microedition.rms.RecordStore;
import javax.microedition.rms.RecordStoreException;
import javax.microedition.rms.RecordStoreFullException;
import javax.microedition.rms.RecordStoreNotFoundException;
import javax.microedition.rms.RecordStoreNotOpenException;

/**
 * class StorageUtility
 *
 * This class provides a persistent record store, built on top of RMS. StorageUtility takes a name which uniquely
 * identifies it, and associates it with several underlying RMSes. Each StorageUtility is meant to store records
 * (objects) of a single type. Different StorageUtilitys can be instantiated (with different names) to handle
 * records/objects of different types.
 *
 * Features of StorageUtility:
 *   * available storage is not limited by the size constraints of a single RMS; records will spill over into
 *     additional RMSes as needed
 *   * records can have their own ID numbers independent of the ID numbers generated by RMS
 *   * access is completely thread-safe
 *   * recover gracefully from RMS errors, particularly RMS full. tries hard to not leave the storage structure in
 *     an inconsistent state, and if it is, you'll at least know about it
 *
 * StorageUtility can be used in two flavors: you manage the IDs, or the utility manages the IDs:
 *
 * If you manage the IDs, the objects you are storing must implement Persistable, which provides the ID from the object
 * itself. You then use the functions read(), write(), and remove() when dealing with storage.
 *
 * If the utility manages the IDs, your objects need only implement Externalizable. You use the functions read(), add(),
 * update(), and remove(). add() will return a new ID for the record, which you then explicitly provide to all subsequent
 * calls to update().
 *
 * These two schemes should not be mixed within the same StorageUtility.
 *
 */
public class RMSStorageUtility<E extends Externalizable> implements IStorageUtility<E>, XmlStatusProvider {
    private static final int MAX_RMS_NAME_LENGTH = 32;        //maximum length of an RMS name
    private static final int SUFFIX_LENGTH = 3;                //how much of RMS name that we need to reserve for our own purposes
    private static final int MAX_DATA_STORES = 100;            //max number of data RMSes

    /* hard-coded ID numbers of specific records in the indexing RMS */
    private static final int TX_FLAG_REC_ID = 1;            //status flag
    private static final int STORAGE_INFO_REC_ID = 2;        //general info (# records, # data stores, etc.)
    protected static final int ID_INDEX_REC_ID = 3;            //record ID -> record location index
    private static final int RESERVE_BUFFER_REC_ID = 4;        //safety buffer

    /* amount of safety buffer we want to keep for unexpected size increases to our indexing structures. this is important as
     * we don't support rolling back updates to the data records. if we successfully change the data, but don't have enough
     * space to update the indexes, the StorageUtility will become corrupt! (which can be repaired, but may result in data loss
     * for the record most recently touched
     */
    private static final int RESERVE_BUFFER_SIZE = 400;

    /* statuses that the StorageUtility may have */
    private static final int STATUS_UNINITIALIZED = -1;        /* StorageUtility still being initialized and not ready for action
                                                               will only be seen in the wild if the constructor failed */
    private static final int STATUS_CLEAN = 0;                /* StorageUtility is in a consistent state and ready for action */
    private static final int STATUS_DIRTY = 1;                /* StorageUtility is in an inconsistent state, meaning some sort of
                                                               transaction is in progress, or the previous transaction failed
                                                               in a way we could not recover from (meaning the StorageUtility
                                                               must be repaired before it can be used again) */

    /* static collection of storage-related objects -- one per unique StorageUtility name -- mainly useful for thread management */
    private static Hashtable storageStaticInfo = new Hashtable();

    private String basename;        //unique name identifying this collection of records
    private Class type;                //type of object this StorageUtility stores
    private boolean allocateIDs;    //if true, will auto-assign IDs to Persistables with an ID of -1

    private RMSFactory rmsFactory;             //Factory for creating storage links

    private RMS[] datastores;        //RMS wrappers for 1..n data RMSes (are loaded as needed, so entries may be null)

    IdIndex index;

    public static final String[] TX_EXCL = {
        RMSTransaction.CACHE_RMS,
        LogEntry.STORAGE_KEY,
        LogEntry.STORAGE_KEY + "F", //logging fallback
        LogEntry.STORAGE_KEY + "E"  //logging fallback
    };

    public RMSStorageUtility (String basename, Class type) {
        this(basename, type, true, new RMSFactory());
    }

    /**
     * Instantiate a new StorageUtility. Will create the underlying skeleton RMSes if they don't exist
     *
     * @param basename unique name identifying this StorageUtility. Different collections of the same type of object
     *   can be kept distinct by giving their StorageUtilitys different names (e.g., "PATIENTS" and "DEMO_PATIENTS")
     * @param type object type that this StorageUtility stores and retrieves. this class must implement Externalizable
     */
    public RMSStorageUtility (String basename, Class type, boolean allocateIDs, RMSFactory factory) {
        rmsFactory = factory;

        validateName(basename);
        validateDataType(type);

        this.basename = basename;
        this.type = type;
        this.allocateIDs = allocateIDs;

        initStaticInfo();

        try {
            loadIndexStore();
            //TODO: better exception for corruption
        } catch(RuntimeException e) {
            //Index store is corrupted.
            repairIndexStore();
        }
    }

    public String getName () {
        return basename;
    }

    public Class getType () {
        return type;
    }

    protected E read(int id, IdIndex index, boolean nullOk) {
        synchronized (getAccessLock()) {

            checkNotCorrupt();

            RMSRecordLoc loc = index.getRecordLoc(id);
            if (loc != null) {
                E e = (E)getDataStore(loc.rmsID).readRecord(loc.recID, type);
                if(e == null) {
                    //if there was a record locator, but no record, something is not ok.
                    repair(true);

                    //TODO: Try to return the record if possible?
                    return null;
                }

                return e;
            } else {
                if(!nullOk) {
                    repair(true);
                }
                return null;
            }

        }
    }

    /**
     * Read and return the record corresponding to 'id'.
     *
     * @param id id of the object
     * @return object for 'id'. null if no object is stored under that ID
     */
    public E read (int id) {
        return read(id, index, true);
    }

    /**
     * Read and return the raw bytes for the record corresponding to 'id'.
     *
     * @param id id of the object
     * @return raw bytes for the record. null if no record is stored under that ID
     */
    public byte[] readBytes (int id) {
        return readBytes(id, true);
    }

    private byte[] readBytes (int id, boolean publicAPI) {
        synchronized (getAccessLock()) {

            if (publicAPI) {
                checkNotCorrupt();
            }

            RMSRecordLoc loc = index.getRecordLoc(id);
            if (loc != null) {
                return getDataStore(loc.rmsID).readRecord(loc.recID);
            } else {
                return null;
            }

        }
    }

    /**
     * Write an object to the store. Will either add a new record, or update the existing record (if one exists) for the
     * object's ID. This function should never be used in conjunction with add() and update() within the same StorageUtility
     *
     * @param p object to store
     */
    public void write (Persistable p) {
        typeCheck(p);

        RMSRecordLoc newLoc = null;

        synchronized (getAccessLock()) {
            RMSStorageInfo info = getInfoRecord();

            int id = p.getID();
            if (allocateIDs) {
                if (id == -1) {
                    id = info.nextRecordID;
                    p.setID(id);
                    info.nextRecordID++;
                } else if (id >= info.nextRecordID) {
                    info.nextRecordID = id + 1;
                }
            }

            byte[] data = ExtUtil.serialize(p);

            RMSRecordLoc loc = index.getRecordLoc(id);

            setDirty();

            //reserve space for updating index/metadata
            int bytesNeededEstimate = (loc == null ? 20 : 40);
            if (!setReserveBuffer(bytesNeededEstimate)) {
                setClean();
                throw new RuntimeException("Record store write failed: Unable to reserve space needed to update index");
            }

            if (loc != null) {
                txRecord(id, "update");
                newLoc = updateRecord(loc, data, info);
            } else {
                txRecord(id, "add");
                newLoc = addRecord(data, info);
                if (newLoc != null) {
                    info.numRecords++;
                }
            }

            //release the space we reserved
            setReserveBuffer(0);

            if (newLoc == null) {
                setClean();
                throw new RuntimeException("Record store write failed");
            }

            index.beginChangeCommit(id, newLoc);
            commitIndex(info, index);
            setClean();
            storageModified();
        }
    }

    /**
     * Add a new record to the store. This function always adds a new record; it never updates an existing record. The
     * record ID under which this record is added is allocated by the StorageUtility. If this StorageUtility stores
     * Persistables, you should almost certainly use write() instead.
     *
     * @param e object to add
     * @return record ID for newly added object
     */
    public int add (E e) {
        typeCheck(e);

        byte[] data = ExtUtil.serialize(e);

        synchronized (getAccessLock()) {
            RMSStorageInfo info = getInfoRecord();
            int id = info.nextRecordID;
            info.nextRecordID++;

            setDirty();

            //reserve space for updating index/metadata
            int bytesNeededEstimate = 40;
            if (!setReserveBuffer(bytesNeededEstimate)) {
                setClean();
                throw new RuntimeException("Record store add failed: Unable to reserve space needed to update index");
            }

            txRecord(id, "add");
            RMSRecordLoc loc = addRecord(data, info);

            //release the space we reserved
            setReserveBuffer(0);

            if (loc == null) {
                setClean();
                throw new RuntimeException("Record store add failed");
            }

            index.beginChangeCommit(id, loc);
            info.numRecords++;

            commitIndex(info, index);
            setClean();
            storageModified();

            return id;
        }
    }

    /**
     * Update a record in the store. The record must have previously been added to the store using add(). If this
     * StorageUtility stores Persistables, you should almost certainly use write() instead.
     *
     * @param id ID of record to update
     * @param e updated object
     * @throws IllegalArgumentException if no record exists for ID
     */
    public void update (int id, E e) {
        typeCheck(e);

        byte[] data = ExtUtil.serialize(e);

        synchronized (getAccessLock()) {
            RMSStorageInfo info = getInfoRecord();
            RMSRecordLoc loc = index.getRecordLoc(id);
            if (loc == null) {
                throw new IllegalArgumentException("Record ID [" + id + "] not found");
            }

            setDirty();

            //reserve space for updating index/metadata
            int bytesNeededEstimate = 20;
            if (!setReserveBuffer(bytesNeededEstimate)) {
                setClean();
                throw new RuntimeException("Record store update failed: Unable to reserve space needed to update index");
            }

            //Move a lot of this logic into the index object
            txRecord(id, "update");
            loc = updateRecord(loc, data, info);

            //release the space we reserved
            setReserveBuffer(0);

            if (loc == null) {
                setClean();
                throw new RuntimeException("Record store update failed");
            }

            index.beginChangeCommit(id, loc);
            commitIndex(info, index);
            setClean();
            storageModified();
        }
    }

    /**
     * Remove record with the given ID from the store.
     *
     * @param id ID of record to remove
     * @throws IllegalArgumentException if no record with that ID exists
     */
    public void remove (int id) {
        synchronized (getAccessLock()) {

            //Start a transaction, if we aren't already inside of one
            final String transactionKey = "remove";
            beginDeleteAction(transactionKey);

            try{

                //Get the current transaction state
                RMSStorageInfo info = (RMSStorageInfo)deleteActionCache[0];
                Hashtable idIndex = (Hashtable)deleteActionCache[1];

                if (!idIndex.containsKey(new Integer(id))) {
                    throw new IllegalArgumentException("Record ID [" + id + "] not found");
                }

                //Perform the actual deletion
                RMSRecordLoc loc = (RMSRecordLoc)idIndex.get(new Integer(id));
                txRecord(id, "delete");
                getDataStore(loc.rmsID).removeRecord(loc.recID);

                //clean up metadata
                info.numRecords--;
                idIndex.remove(new Integer(id));

            } catch(RuntimeException e) {
                throw e;
            } finally {
                //commit transaction (if we opened it)
                completeDeleteAction(transactionKey);
            }
        }
    }


    //these two objects contain the meta state of the store during a delete transaction
    //If they are null, no transaction should be ocurring
    /** RMSStorageInfo, Hashtable **/
    private Object[] deleteActionCache;
    //The object key representing the current transaction
    private Object transactionKey;

    //Begins an atomic delete transaction, and captures the current state of the storage
    //which it will use until that transaction is complete
    private Object[] beginDeleteAction(Object transactionKey) {
        synchronized (getAccessLock()) {
            //check to see if something else owns the transaction handle
            if(this.transactionKey != null) {
                if(!this.transactionKey.equals(transactionKey)) {
                    return deleteActionCache;
                } else {
                    throw new RuntimeException("Improperly structured atomic delete action (multiple transaction openings from same path)");
                }
            }


            RMSStorageInfo info = getInfoRecord();
            Hashtable idIndex = index.getIndexTable();

            deleteActionCache = new Object[] {info, idIndex};
            this.transactionKey = transactionKey;

            setDirty();
            return deleteActionCache;
        }
    }

    //Commits the delete action by updating all of the metadata and index information,
    //and releases the transaction locks
    private void completeDeleteAction(Object transactionKey) {
        synchronized (getAccessLock()) {

            //If there's no data cached, this transaction is completely incorrect.
            if(this.transactionKey == null || deleteActionCache == null) {
                throw new RuntimeException("Improperly structured atomic delete action");
            }

            //See if the action in question owns this transaction, if not
            //we need to bail
            if(!this.transactionKey.equals(transactionKey)) {
                return;
            }

            RMSStorageInfo info = (RMSStorageInfo)deleteActionCache[0];
            Hashtable idIndex = (Hashtable)deleteActionCache[1];

            index.beginChangeCommit(idIndex);
            commitIndex(info, index);

            this.deleteActionCache = null;
            this.transactionKey = null;

            setClean();
            storageModified();
        }
    }


    /**
     * Remove object from the store
     *
     * @param p object to remove
     * @throws IllegalArgumentException if object is not in the store
     */
    public void remove (Persistable p) {
        typeCheck(p);

        remove(p.getID());
    }

    public void removeAll () {
        removeAll(null);
    }

    public Vector<Integer> removeAll (EntityFilter filter) {
        synchronized (getAccessLock()) {
            Vector IDs = new Vector();

            IStorageIterator ii = iterate();
            while (ii.hasMore()) {
                int id = ii.nextID();
                boolean toRemove;

                if (filter == null) {
                    toRemove = true;
                } else {
                    switch (filter.preFilter(id, null)) {
                    case EntityFilter.PREFILTER_INCLUDE: toRemove = true; break;
                    case EntityFilter.PREFILTER_EXCLUDE: toRemove = false; break;
                    case EntityFilter.PREFILTER_FILTER: toRemove = filter.matches(read(id)); break;
                    default: throw new RuntimeException();
                    }
                }

                if (toRemove) {
                    IDs.addElement(new Integer(id));
                }
            }
            final String transactionKey = "removeAll";

            //Begin an atomic delete action, and capture/cache state variables
            beginDeleteAction(transactionKey);

            try {
                //Delete the records
                for (int i = 0; i < IDs.size(); i++) {
                    int id = ((Integer)IDs.elementAt(i)).intValue();
                    remove(id);
                }
            } catch(RuntimeException e) {
                throw e;
            } finally {
                //Complete the action, and commit the cached variables.
                completeDeleteAction(transactionKey);
            }

            return IDs;
        }
    }

    /**
     * Return the number of records in the store
     *
     * @return number of records
     */
    public int getNumRecords () {
        synchronized (getAccessLock()) {

            checkNotCorrupt();

            return getInfoRecord().numRecords;

        }
    }

    /**
     * Return whether the store is empty
     *
     * @return true if there are no records in the store
     */
    public boolean isEmpty () {
        return getNumRecords() == 0;
    }

    /**
     * Return whether a record exists in the store
     *
     * @param id record ID
     * @return true if a record exists for that ID in the store
     */
    public boolean exists (int id) {
        synchronized (getAccessLock()) {

            checkNotCorrupt();

            return index.containsRecordLoc(id);
        }
    }

    /**
     * Return total size used by this StorageUtility, including all underlying RMSes
     *
     * @return total size (bytes)
     */
    public int getTotalSize () {
        int size = 0;

        synchronized (getAccessLock()) {

            checkNotCorrupt();

            RMSStorageInfo info = getInfoRecord();

            try {
                size += index.getIndexStoreSize();
                for (int i = 0; i < info.numDataStores; i++) {
                    size += getDataStore(i).rms.getSize();
                }
            } catch (RecordStoreNotOpenException e) {
                throw new RuntimeException("can't happen");
            }
        }

        return size;
    }

    /**
     * Get the size of a record
     *
     * @param id record ID
     * @return size of that record, in bytes
     * @throws IllegalArgumentException if no record exists for that ID
     */
    public int getRecordSize (int id) {
        synchronized (getAccessLock()) {

            checkNotCorrupt();

            RMSRecordLoc loc = index.getRecordLoc(id);
            if (loc != null) {
                try {
                    return getDataStore(loc.rmsID).rms.getRecordSize(loc.recID);
                } catch (RecordStoreException e) {
                    throw new RuntimeException("error getting record size");
                }
            } else {
                throw new IllegalArgumentException("Record ID [" + id + "] not found");
            }

        }
    }

    /**
     * Delete the storage utility itself, along with all stored records and meta-data
     */
    public void destroy () {
        synchronized (getAccessLock()) {
            if (RMSTransaction.anyTxOpen()) {
                throw new RuntimeException("operation not allowed while transactions are active");
            }

            throw new RuntimeException("not implemented yet");
        }
    }

    /**
     * Perform any clean-up/consolidation of the StorageUtility's underlying datastructures that is too expensive to do during
     * normal usage (e.g., if all the records are scattered among 10 half-empty RMSes, repack them into 5 full RMSes)
     */
    public void repack () {
        synchronized (getAccessLock()) {
            if (RMSTransaction.anyTxOpen()) {
                throw new RuntimeException("operation not allowed while transactions are active");
            }

            throw new RuntimeException("not implemented yet");
        }
    }

    /**
     * If the StorageUtility has been left in a corrupt/inconsistent state, restore it to a non-corrupt state, even if it results
     * in data loss
     */
    public void repair () {
        repair(false);
    }

    private void repair(boolean force) {
        synchronized (getAccessLock()) {
            if (RMSTransaction.anyTxOpen()) {
                throw new RuntimeException("operation not allowed while transactions are active");
            }

            try {
                checkNotCorrupt();
                if(force) { throw new IllegalStateException("An internal constraint was violated");}

                //integrity is ok
                return;

            } catch (IllegalStateException ise) {
                //utility is corrupt; fix it
                log("rms-repair", "buf[" + getReserveBufferSize() + "]");

                Hashtable<RMSRecordLoc, Boolean> realRecords = new Hashtable<RMSRecordLoc, Boolean>();

                //Enumerate all of the records which exist
                for(int id = 0; id < datastores.length; ++ id) {
                    int numPossible = -1;
                    try {
                        if(datastores[id] == null) {
                            try {
                                datastores[id] = this.getDataStore(id);
                            } catch (Exception e) {
                                log("rms-repair", "Un-openable record store " + this.getName() + " [" + id+ "]");
                                throw new RuntimeException("Unable to open storage [" + this.getName()+": " + id+ "]. Please ensure all media is plugged in and try again.");
                            }
                        }
                        numPossible = datastores[id].rms.getNumRecords();
                    } catch(Exception e) {
                        log("rms-repair", "Error getting num records(" + e.getClass() + ": " + e.getMessage() + ")");
                    }
                    log("rms-repair", "Enumerating recordStore: " + id + " to check " + numPossible + " records");
                    int old = realRecords.size();
                    datastores[id].listRecords(realRecords, id);
                    log("rms-repair", "Located " + (realRecords.size() - old) + " records");
                }
                log("rms-repair", "Existing records enumerated");

                RMSStorageInfo info = getInfoRecord();

                log("rms-repair", "Retrieving index table for repair");

                Hashtable idIndex = index.getIndexTable();

                //check index for entries where record does not exist in rms
                Vector invalidIDs = new Vector();
                int max_datastore = -1;

                log("rms-repair", "Enumerating RMS Index items");
                for (Enumeration e = idIndex.keys(); e.hasMoreElements(); ) {
                    int id = ((Integer)e.nextElement()).intValue();
                    RMSRecordLoc loc = (RMSRecordLoc)idIndex.get(new Integer(id));
                    if (loc.rmsID > max_datastore) {
                        max_datastore = loc.rmsID;
                    }

                    //remove this record from the table to signify that it's currently known
                    if(realRecords.containsKey(loc)) {
                        realRecords.remove(loc);
                    }

                    boolean recordExists = false;
                    if (loc.rmsID >= info.numDataStores) {
                        log("rms-corrupt", id + " => (" + loc.rmsID + "," + loc.recID + ") data store out of range [" + info.numDataStores + "]");
                    } else {
                        RMS rms = getDataStore(loc.rmsID);
                        if (rms != null && rms.readRecord(loc.recID) != null) {
                            recordExists = true;
                        } else {
                            log("rms-corrupt", id + " => (" + loc.rmsID + "," + loc.recID + ") no record exists");
                        }
                    }

                    if (!recordExists) {
                        invalidIDs.addElement(new Integer(id));
                    }
                }

                log("rms-repair", "Removing " + invalidIDs.size() + " corrupted records from index");
                for (int i = 0; i < invalidIDs.size(); i++) {
                    idIndex.remove((Integer)invalidIDs.elementAt(i));
                }

                //check for rms records that have no corresponding index entry
                //note: this is hte most likely failure scenario
                //TODO -- it's not going to hurt anything for now

                int nextID = idIndex.size() + 1;

                //Any records which exist in this table now represent values _unknown_ to the
                //record store. We'll add them back (TODO: Maybe see whether some were
                //part of a transaction and sohldn't be?)
                for(Enumeration en = realRecords.keys() ; en.hasMoreElements(); ) {
                    RMSRecordLoc loc = (RMSRecordLoc)en.nextElement();
                    idIndex.put(new Integer(nextID), loc);
                    //TODO: The internal record ID's and Persistable record Id's won't necessarily
                    //match up after this op?
                    this.log("rms-corrupt", "Re-Indexed record: " + this.getName() + ": " + nextID + " => (" + loc.rmsID + "," + loc.recID + ")");
                    nextID++;

                    if(loc.rmsID > max_datastore) {
                        max_datastore = loc.rmsID;
                    }
                }

                //check for uncommitted spillover
                try {
                    RMS spilled = rmsFactory.getDataRMS(dataStoreName(info.numDataStores), false);
                    if (spilled != null && spilled.rms.getNumRecords() > 0) {
                        log("rms-corrupt", "uncommitted spillover rms found");
                    }
                } catch (RecordStoreException rse) {
                    //ok
                }

                info.numRecords = idIndex.size();
                info.numDataStores = max_datastore + 1;
                info.nextRecordID = info.numRecords + 1;

                index.beginChangeCommit(idIndex);
                commitIndex(info, index);
                setReserveBuffer(0);
                setClean();
                storageModified();

                //check again
                try {
                    checkNotCorrupt();
                    log("rms-repair", "storage utility repaired successfully");
                } catch (IllegalStateException ise2) {
                    log("rms-repair", "unable to repair storage utility!!!");
                    throw new IllegalStateException("Storage utility [" + basename + "] is corrupt and could not be repaired");
                }
            }
        }
    }

    private void repairIndexStore() {

        //NOTE: There are some _serious_ timing problems here where things can get into a very bad
        //state.

        log("storage-corrupt", "Index Storage is corrupted. Attempting to recreate");

        RMS ix = null;
        if(index != null && index.getIndexStore() != null) {
            ix = index.getIndexStore();
        } else {
            try {
                ix = rmsFactory.getIndexRMS(indexStoreName(), false);
            } catch(RecordStoreException rse) {
                //Storage is not valid.
            }
        }

        //We expect these might be null
        byte[] storageInfo = null;
        byte[] indexData = null;
        //If we have storage, see if we can get anything from it
        if(ix != null) {
            //TODO: see if
            //Get any of the living data if it's working
            try {
                storageInfo = ix.readRecord(STORAGE_INFO_REC_ID);
            } catch(RuntimeException rse) {
                //corrupt
            }
            try {
                indexData = ix.readRecord(ID_INDEX_REC_ID);
            } catch(RuntimeException rse) {
                //corrupt
            }
            //Don't worry about the buffer or status...
        }

        //ok, so we have all the data we're gonna have.

        if(ix != null) {
            ix.close();
        }

        //Delete the record store if it still exists.
        try {
            RecordStore.deleteRecordStore(indexStoreName());
        } catch(RecordStoreNotFoundException rsnfe) {
            //well this is the point....
        } catch (RecordStoreException e) {
            String message ="Couldn't wipe to repair record store index " + indexStoreName() + ": " + e.getMessage();
            log("storage-corrupt", message);
            //if it's not gone, it's a huge problem
            throw new RuntimeException(message);
        }

        //Create and initialize a new index store.
        this.initIndexStore();

        ix = index.getIndexStore();

        boolean infoRecordRecovered = false;
        if(storageInfo != null) {
            ix.updateRecord(STORAGE_INFO_REC_ID, storageInfo, true);
            infoRecordRecovered = true;
        }

        if(!infoRecordRecovered) { log("storage-corrupt", indexStoreName() + ": " +"Couldn't recover info record");}
        else { log("storage-corrupt", "Recovered Info Record");};

        boolean indexDataRecoverd = false;
        if(indexData != null) {
            ix.updateRecord(ID_INDEX_REC_ID, indexData, true);
            indexDataRecoverd = true;
        }

        if(!indexDataRecoverd) { log("storage-corrupt", indexStoreName() + ": " +"Couldn't recover index data");}
        else { log("storage-corrupt", "Recovered index data");};


        //Ok, manually go fix anything that we didn't fix

        if(!infoRecordRecovered) {
            RMSStorageInfo info = (RMSStorageInfo)ix.readRecord(STORAGE_INFO_REC_ID, RMSStorageInfo.class);

            //Figure out how many record stores we have
            int stores = 0;
            boolean failed = false;
            while(!failed) {
                try {
                    RMS rms = rmsFactory.getDataRMS(dataStoreName(stores), false);
                    stores++;
                    rms.close();
                } catch (RecordStoreException rse) {
                    failed = true;
                }
            }
            info.numDataStores = stores;
            log("storage-corrupt", indexStoreName() + ": Discovered " + stores + " RMS files");

            if(!ix.updateRecord(STORAGE_INFO_REC_ID, ExtUtil.serialize(info), true)) {
                //TODO: What if we can't recover this record?
            }
        }

        //Alright, now initialize the rest of the data.
        this.datastores = new RMS[0];
        getInfoRecord();

        for(int i = 0 ; i < datastores.length ; ++i) {
            log("storage-corrupt", indexStoreName() + ": Initializing store: " + i);
            this.getDataStore(i);
            datastores[i].ensureOpen();
            log("storage-corrupt", indexStoreName() + ": Store " + i + " reinitialized");
        }

        //and repair the rest
        this.repair(true);
    }

    /**
     * Attempt to commit all changes to the indexing and meta-data structures after a record operation (add/update/remove) has been
     * done. Throw a fatal exception if any of these commits fail. It is the responsibility of the caller to ensure that there is
     * enough space to write these updates (such as by reserving a 'safety buffer' of bytes then releasing it immediately prior to
     * this call). We have no provision for rolling back record changes (add/update/remove), so if these commits fail, the
     * StorageUtility will be left in a corrupt state, necessitating repair (which in turn may result in data loss). So it is
     * important to reserve the necessary space.
     *
     * @param info general StorageUtility info record
     * @param idIndex ID -> record location mapping
     */
    private void commitIndex (RMSStorageInfo info, IdIndex index) {
        boolean failed = false;

        if (!failed) {
            //TODO: More efficiently?
            failed = !index.commitChange();
        } if (!failed) {
            failed = !writeInfoRecord(info);
        }

        if (failed) {
            System.err.println("We weren't able to commit the updated index and meta-data, even though we thought we had enough space! The utility is now corrupt!!");
            log("rms-corrupt", "unable to commit index; utility is now corrupt");
            throw new RuntimeException("ERROR! Enable to complete action! Utility must be repaired!");
        }
    }

    /**
     * Close all resources associated with this StorageUtility. Any attempt to use this StorageUtility after this call will result
     * in error. Though not strictly necessary, it is a good idea to call this when you are done with the StorageUtility, as closing
     * may trigger clean-up in the underlying RMSes (device-dependent behavior) which may reclaim unused space.
     *
     * Don't worry about other StorageUtilitys that reference the same data (such as in other threads); they will reopen their
     * RecordStores as needed.
     */
    public void close () {
        synchronized (getAccessLock()) {
            index.release();
            index = null;

            for (int i = 0; i < datastores.length; i++) {
                if (datastores[i] != null) {
                    datastores[i].close();
                }
            }
            datastores = null;
        }
    }

    /**
     * Return an iterator to iterate through all records in this StorageUtility
     *
     * @returns record iterator
     */
    public IStorageIterator iterate () {
        synchronized (getAccessLock()) {

            checkNotCorrupt();

            return newIterator(index);
        }
    }

    /**
     * Trigger for when something modifies the data in the storage utility
     */
    private void storageModified () {
        invalidateIterators();
    }

    /**
     * Load the indexing/meta-data RMS when this StorageUtility is first instantiated, and check its integrity. Create
     * it if it doesn't exist.
     */
    private void loadIndexStore () {
        synchronized (getAccessLock()) {

            RMS ix = null;
            try {
                ix = rmsFactory.getIndexRMS(indexStoreName(), false);
            } catch (RecordStoreNotFoundException rsnfe) {
                //do nothing; will create record store next
            } catch (RecordStoreException rse) {
                throw new RuntimeException("Error + (" + rse.getClass().getName() + ") opening index record for store " + basename + " : " + rse.getMessage());
            }

            if (ix != null) {
                this.index = new IdIndex(ix);
            } else {
                initIndexStore();
            }

            checkInitialized();

            this.datastores = new RMS[0];
            getInfoRecord();

            try {
                //this gets wrapped (with questionable value!!!) later on, so if we're going to
                //catch errors with it and trigger a repair, we need to do it early!
                index.getIndexStore().rms.getRecordSize(RESERVE_BUFFER_REC_ID);
            } catch (RecordStoreNotFoundException rsnfe) {
                throw new RuntimeException("Error + (" + rsnfe.getClass().getName() + ") getting reserve buffer for store " + basename + " : " + rsnfe.getMessage());
            } catch (RecordStoreException rse) {
                throw new RuntimeException("Error + (" + rse.getClass().getName() + ") getting reserve buffer for store " + basename + " : " + rse.getMessage());
            }
        }
    }

    /**
     * Create a new indexing/meta-data RMS. The RMS must not exist already.
     */
    private void initIndexStore () {
        RMS ix = null;
        try {
            ix = rmsFactory.getIndexRMS(indexStoreName(), true);
        } catch (RecordStoreException rse) {
            throw new RuntimeException("Error creating index record: " + rse.getMessage());
        }

        int recID;

        //initialize status flag
        recID = ix.addRecord(ExtUtil.serialize(new Integer(STATUS_UNINITIALIZED)));
        if (recID != TX_FLAG_REC_ID) {
            throw new RuntimeException("Error building meta RMS: record not assigned to expected ID");
        }

        //create default storage info
        recID = ix.addRecord(ExtUtil.serialize(new RMSStorageInfo()));
        if (recID != STORAGE_INFO_REC_ID) {
            throw new RuntimeException("Error building meta RMS: record not assigned to expected ID");
        }

        //create empty record ID index
        recID = ix.addRecord(ExtUtil.serialize(new ExtWrapMap(new Hashtable())));
        if (recID != ID_INDEX_REC_ID) {
            throw new RuntimeException("Error building meta RMS: record not assigned to expected ID");
        }

        //create buffer of reserve bytes
        recID = ix.addRecord(new byte[1]); //RMS has trouble with zero-length records
        if (recID != RESERVE_BUFFER_REC_ID) {
            throw new RuntimeException("Error building meta RMS: record not assigned to expected ID");
        }

        this.index = new IdIndex(ix);

        setClean();
    }

    /**
     * Add a new record to the data stores. Attempts to add the record to each data store, starting with the lowest,
     * until it finds a data store that is not full and successfully accepts the record. If all data stores are full,
     * attempt to spillover by creating and adding to an additional data store.
     *
     * If a spillover data store is created, but does not have enough space for the record, the new (empty) data store is removed
     *
     * @param data serialized byte data for record
     * @param info StorageUtility info record
     * @return location record was added to (RMS #, record ID); null if storage is full
     */
    private RMSRecordLoc addRecord (byte[] data, RMSStorageInfo info) {
        RMSRecordLoc newID = null;
        int iDatastore;

        for (iDatastore = info.numDataStores - 1; iDatastore >= 0; iDatastore--) {
            RMS rs = getDataStore(iDatastore);
            int recID = rs.addRecord(data);

            if (recID != -1) {
                newID = new RMSRecordLoc(iDatastore, recID);
                break;
            } //else, not enough space in recordstore for record
        }

        if (newID == null) {
            logSpill(info.numDataStores, "attempting spill-over", true);
            RMS rs = newDataStore(info);
            if (rs != null) {
                iDatastore = info.numDataStores - 1;
                int recID = rs.addRecord(data);
                if (recID != -1) {
                    logSpill(iDatastore, "success", true);
                    newID = new RMSRecordLoc(iDatastore, recID);
                } else {
                    logSpill(iDatastore, "spillover write failed", false);
                    //not enough space in spillover RMS to store new record
                    //remove newly-created spillover RMS so it's not lying around empty
                    removeLastDataStore(info);
                }
            } else {
                //could not create spillover recordstore; entire RMS system is full
                logSpill(info.numDataStores, "failed to create spillover", false);
            }
        }

        return newID;
    }

    private void logSpill (int dataStoreNum, String msg, boolean ignoreForFirst) {
        if (!ignoreForFirst || dataStoreNum > 0) {
            log("rms-spill", "#" + dataStoreNum + " " + msg);
        }
    }

    /**
     * Update a record in the data stores. It always tries to add a new record with the updated data, and then delete the
     * old record. This is because (on some phones, at least), the RMS gets completely hosed if you try to update a record
     * in place and there isn't enough space.
     *
     * @param curLoc current location (RMS #, record ID) of the record
     * @param data serialized byte data for record
     * @param info StorageUtility info record
     * @return new location of the record; null if storage is full
     */
    private RMSRecordLoc updateRecord (RMSRecordLoc curLoc, byte[] data, RMSStorageInfo info) {
        RMSRecordLoc newID = addRecord(data, info);
        if (newID != null) {
            getDataStore(curLoc.rmsID).removeRecord(curLoc.recID);
            return newID;
        } else {
            return null;
        }
    }


    /**
     * Return a reference to one of the data RMSes. Data RMSes are loaded lazily, so will load it if it has not been
     * previously loaded. Will also re-open it if closed by another thread.
     *
     * @param i number of data store RMS to retrieve
     * @return reference to data RMS
     * @throws IllegalArgumentException if i is out of the range of existing data stores for this StorageUtility
     */
    private RMS getDataStore (int i) {
        if (i < 0 || i >= datastores.length) {
            throw new IllegalArgumentException("Data store [" + i + "] out of range");
        }

        RMS data = datastores[i];
        if (data == null) {
            try {
                data = rmsFactory.getDataRMS(dataStoreName(i), false);
            } catch (RecordStoreException rse) {
                throw new RuntimeException("Error opening data store " + i + "; " + rse.getMessage());
            }
            datastores[i] = data;
        } else {
            data.ensureOpen();
        }
        return data;
    }

    /**
     * Create (and cache) a new data store RMS for spillover
     *
     * @param info StorageUtility info record
     * @return a reference to the new data store RMS, null if the entire device is full or max # of data stores exceeded
     */
    private RMS newDataStore (RMSStorageInfo info) {
        if (info.numDataStores == MAX_DATA_STORES) {
            System.out.println("Warning: maximum number of data RMSes exceeded in StorageUtility [" + basename + "]; repacking the StorageUtility may reclaim space and allow more records to be added");
            return null;
        }

        RMS rs = null;
        try {
            rs = rmsFactory.getDataRMS(dataStoreName(info.numDataStores), true);
        } catch (RecordStoreFullException e) {
            return null;
        } catch (RecordStoreException e) {
            throw new RuntimeException("Error creating spillover datastore; " + e.getMessage());
        }

        //rs must not be null at this point
        try {
            if (rs.rms.getNumRecords() != 0) {
                logSpill(info.numDataStores, "spillover store not empty!", false);

                //attempt to clear it out
                try {
                    Vector<Integer> IDs = new Vector<Integer>();
                    for (RecordEnumeration re = rs.rms.enumerateRecords(null, null, false); re.hasNextElement(); ) {
                        IDs.addElement(new Integer(re.nextRecordId()));
                    }
                    for (int i = 0; i < IDs.size(); i++) {
                        rs.rms.deleteRecord(IDs.elementAt(i).intValue());
                    }
                } catch (RecordStoreException rse) {
                    logSpill(info.numDataStores, "error emptying out new data store: " + WrappedException.printException(rse), false);
                }
            }
        } catch (RecordStoreNotOpenException e) {
            throw new RuntimeException("can't happen");
        }

        info.numDataStores++;
        resizeDatastoreArray(info);
        datastores[info.numDataStores - 1] = rs;

        return rs;
    }

    /**
     * Remove and destroy the most-recently created (highest numbered) data store RMS. RMS must be empty.
     *
     * @param info StorageUtility info record
     */
    private void removeLastDataStore (RMSStorageInfo info) {
        int i = info.numDataStores - 1;
        RMS rs = getDataStore(i);

        try {
            if (rs.rms.getNumRecords() != 0) {
                throw new IllegalStateException("Attempted to remove a datastore that is not empty!");
            }
        } catch (RecordStoreNotOpenException e) {
            throw new RuntimeException("can't happen");
        }

        rs.close();
        try {
            RecordStore.deleteRecordStore(rs.name);
        } catch (RecordStoreNotFoundException e) {
            throw new RuntimeException("Programmer logic error");
        } catch (RecordStoreException e) {
            throw new RuntimeException("Error deleting datastore");
        }

        info.numDataStores--;
        resizeDatastoreArray(info);
    }

    /**
     * Check the type of an object against the type registered for use with this StorageUtility. Print a warning
     * if they differ (does not necessarily mean the two types are incompatible, but they probably are).
     *
     * @param o new object
     */
    private void typeCheck (Object o) {
        if (o.getClass() != type) {
            System.err.println("Warning: attempting to use type [" + o.getClass().getName() + "] with storage utility of type [" + type.getName() + "]; ensure their serializations are compatible!");
        }
    }

    /**
     * Return the name of the indexing/meta-data RMS, constructed from this StorageUtility's base name
     *
     * @return RMS name
     */
    private String indexStoreName () {
        return basename + "_IX";
    }

    /**
     * Return the name of one of the data store RMSes, constructed from this StoageUtility's base name
     *
     * @param i number of data store
     * @return RMS name
     */
    private String dataStoreName (int i) {
        if (i < 0 || i >= MAX_DATA_STORES) {
            throw new IllegalArgumentException("Data stores can only be numbered 0 through " + MAX_DATA_STORES + " [" + i + "]");
        }
        return basename + "_" + DateUtils.intPad(i, 2);
    }

    /**
     * Validate that the StorageUtility base name meets all requirements
     *
     * @param basename base name of storage utility
     */
    private void validateName (String basename) {
        if (basename.length() > MAX_RMS_NAME_LENGTH - SUFFIX_LENGTH) {
            throw new IllegalArgumentException("Cannot create storage utility. Utility base name [" + basename + "] exceeds J2ME length limits");
        }
    }

    /**
     * Validate that the record type for this StorageUtility meets all requirements
     *
     * @param type Class object for the type of object this StorageUtility will handle
     */
    private void validateDataType (Class type) {
        if (Externalizable.class.isAssignableFrom(type)) {
            try {
                PrototypeFactory.getInstance(type);
            } catch (CannotCreateObjectException ccoe) {
                throw new IllegalArgumentException("Cannot create storage utility. Type [" + type.getName() + "] cannot be used. (" + ccoe.getMessage() + ")");
            }
        } else {
            throw new IllegalArgumentException("Cannot create storage utility. Type [" + type.getName() + "] is not externalizable.");
        }
    }

    /**
     * Load the StorageUtility info record from the indexing/meta-data RMS
     *
     * @return info record
     */
    private RMSStorageInfo getInfoRecord () {
        //TODO: All of this logic needs to move to the IdIndex!
        RMSStorageInfo info = (RMSStorageInfo)index.getIndexStore().readRecord(STORAGE_INFO_REC_ID, RMSStorageInfo.class);

        if(info == null) {
            throw new RuntimeException("RMS Storage Info record is corrupted");
        }

        if (info.numDataStores != datastores.length) {
            resizeDatastoreArray(info);
        }

        return info;
    }

    /**
     * Commit the StorageUtility info record back to RMS
     *
     * @param info info record
     * @return true if record committed successfully; false if full
     */
    private boolean writeInfoRecord (RMSStorageInfo info) {
        return index.getIndexStore().updateRecord(STORAGE_INFO_REC_ID, ExtUtil.serialize(info), true);
    }

    /**
     * Resize the array of cached references to data store RMSes
     *
     * @param info StorageUtility info record, from which the new number of data stores is taken
     */
    private void resizeDatastoreArray (RMSStorageInfo info) {
        RMS[] old = datastores;
        datastores = new RMS[info.numDataStores];
        System.arraycopy(old, 0, datastores, 0, Math.min(old.length, datastores.length));
    }

//    /**
//     * Load the ID index from the indexing/meta-data RMS
//     *
//     * @return index hashtable, which maps integer record ID -> record locator
//     */
//    public Hashtable getIDIndexRecord () {
//        //If we're in the middle of a transaction, we get this index from that
//        //transaction (so we don't have to keep reading/writing it)
//        if(this.transactionKey != null) {
//            return (Hashtable)this.deleteActionCache[1];
//        }
//        return (Hashtable)getIndexStore().readRecord(ID_INDEX_REC_ID, new ExtWrapMap(Integer.class, RMSRecordLoc.class));
//    }

//    /**
//     * Commit the record ID index back to RMS
//     *
//     * @param idIndex record ID index
//     * @return true if record committed successfully; false if full
//     */
//    private boolean writeIDIndexRecord (Hashtable idIndex) {
//        return getIndexStore().updateRecord(ID_INDEX_REC_ID, ExtUtil.serialize(new ExtWrapMap(idIndex)), true);
//    }

    /**
     * Reserve bytes for later usage. If 'size' is greater than zero, that amount of bytes plus a fixed 'safety margin'
     * will be reserved (i.e., allocated into a designated record). If 'size' is zero, all reserved bytes will be released,
     * including the safety margin (i.e., the designated record is resized to the minimum possible size).
     *
     * @param size number of bytes to reserve (or 0 to release)
     * @return true if bytes were allocated successfully; false if full
     */
    private boolean setReserveBuffer (int size) {
        //TODO: MOVE TO THE IdIndex!
        int bufsize = (size <= 0 ? 1 : size + RESERVE_BUFFER_SIZE);
        return index.getIndexStore().updateRecord(RESERVE_BUFFER_REC_ID, new byte[bufsize], true);
    }

    private int getReserveBufferSize () {
        try {
            return index.getIndexStore().rms.getRecordSize(RESERVE_BUFFER_REC_ID);
        } catch (Exception e) {
            return -1;
        }
    }

    /**
     * Check that the StorageUtility has been properly initialized. Throw an exception if it is not
     */
    public void checkInitialized () {
        checkStatusOK(true);
    }

    /**
     * Check that the StorageUtility is in an initialized, consistent, non-corrupt state. Throw an exception if it is not
     *
     * If the StorageUtility was not properly initialized, this call will fail.
     * If transactions on this StorageUtility are currently in progress (such as by other threads), or a past transaction
     *   failed and did not properly clean itself up, this call will fail.
     */
    public void checkNotCorrupt () {
        if(this.transactionKey == null) {
            //If we're not in a transaction, dirty won't cut it
            checkStatusOK(false);
        } else {
            //Otherwise, it's ok if we're dirty, since we're currently doing something
            checkStatusOK(true);
        }
    }

    /**
     * Check the status of the StorageUtility, throwing fatal exceptions if it is in a disallowed state.
     *   UNINITIALIZED is always a disallowed state
     *   CLEAN is always an allowed state
     *   DIRTY is allowed or disallowed depending on the parameter 'dirtyOK'
     *
     * @param dirtyOK if true, DIRTY is an allowed status; if false, the DIRTY status will cause a fatal exception
     */
    private void checkStatusOK (boolean dirtyOK) {
        int status = getStatus();

        if (status == STATUS_DIRTY) {
            if (!dirtyOK) {
                throw new IllegalStateException("Storage utility [" + basename + "] is in a corrupted state. You must repair it before you can access it again");
            }
        } else if (status != STATUS_CLEAN) {
            throw new IllegalStateException("Storage utility [" + basename + "] was not initialized properly, is pointing at the wrong RMSes, or is otherwise seriously broken. You will likely have to delete it and start over.");
        }
    }

    /**
     * Fetch the StorageUtility status flag
     *
     * @return status flag code
     */
    private int getStatus () {
        Integer statusObj = null;
        try {
            statusObj = (Integer)index.getIndexStore().readRecord(TX_FLAG_REC_ID, Integer.class);
        } catch (RuntimeException re) {
            //do nothing
            System.err.println("RuntimeException while trying to read StorageUtility status flag; could be transient or could be a serious problem with RMS; " + re.getMessage());
        }
        return (statusObj != null ? statusObj.intValue() : STATUS_UNINITIALIZED);
    }

    /**
     * Set the status to DIRTY, indicating a transaction is in progress. Checks first to see that the status is
     * CLEAN, else throws a fatal exception.
     */
    private void setDirty () {
        checkNotCorrupt();
        index.getIndexStore().updateRecord(TX_FLAG_REC_ID, ExtUtil.serialize(new Integer(STATUS_DIRTY)), true);
    }

    /**
     * Set the status to CLEAN, indicating any transaction is now complete, and the StorageUtility is in a consistent state.
     */
    private void setClean () {
        index.getIndexStore().updateRecord(TX_FLAG_REC_ID, ExtUtil.serialize(new Integer(STATUS_CLEAN)), true);
    }



    /**
     * Create an entry for this StorageUtility (unique to this utility's base name) in the static table of synchronization
     * objects.
     */
    private void initStaticInfo () {
        synchronized (storageStaticInfo) {
            if (!storageStaticInfo.containsKey(basename)) {
                storageStaticInfo.put(basename, new StorageStaticEntity());
            }
        }
    }

    /**
     * Fetch the object that acts as the synchronization lock for this StorageUtility
     *
     * @return lock object
     */
    public Object getAccessLock () {
        synchronized (storageStaticInfo) {
            return ((StorageStaticEntity)storageStaticInfo.get(basename)).lock;
        }
    }

    /**
     * Create a new record iterator and register it
     *
     * @param index list of record IDs to iterate over
     * @return record iterator
     */
    private RMSStorageIterator newIterator (IdIndex index) {
        RMSStorageIterator iter = new RMSStorageIterator(this, index);

        synchronized (storageStaticInfo) {
            ((StorageStaticEntity)storageStaticInfo.get(basename)).iterators.addElement(iter);
        }

        return iter;
    }

    /**
     * Callback from iterator when its iteration is complete
     *
     * @param iter iterator making the callback
     */
    public void iteratorComplete (RMSStorageIterator iter) {
        synchronized (storageStaticInfo) {
            ((StorageStaticEntity)storageStaticInfo.get(basename)).iterators.removeElement(iter);
        }
    }

    /**
     * When this StorageUtility has been modified (record add/update/remove), this will invalidate and
     * unregister all active iterators
     */
    private void invalidateIterators () {
        synchronized (storageStaticInfo) {
            Vector iterators = ((StorageStaticEntity)storageStaticInfo.get(basename)).iterators;

            for (int i = 0; i < iterators.size(); i++) {
                ((RMSStorageIterator)iterators.elementAt(i)).invalidate();
            }

            iterators.removeAllElements();
        }
    }

    /**
     * Stores objects that need to be maintained per storage entity (meaning, per unique basename). Multiple StorageUtilitys
     * can be instantiated at once with the same basename, so this shared object is necessary.
     */
    private class StorageStaticEntity {
        public Object lock;                    //synchronization lock for this storage
        public Vector iterators;            //list of active record enumerations over this storage

        public StorageStaticEntity () {
            lock = new Object();
            iterators = new Vector();
        }
    }

    private void txRecord (int recordID, String opType) {
        for (int i = 0; i < TX_EXCL.length; i++) {
            if (TX_EXCL[i].equals(getName()))
                return;
        }

        RMSTransaction tx = RMSTransaction.getTx();
        if (tx == null) { //no active transaction
            return;
        }

        if (!tx.isRecordTouched(getName(), recordID)) {
            try {
                RMSStorageUtility tx_cache = RMSTransaction.getCacheRMS();
                boolean recordExists = !"add".equals(opType);
                int entry_id = tx_cache.add(new TxCacheEntry(tx, getName(), recordID, recordExists ? readBytes(recordID, false) : null));
                tx.recordTouched(getName(), recordID, entry_id);
            } catch (Exception e) {
                Logger.log("rms-tx", "error during rms transaction back-up operation");
                Logger.exception(e);
                throw new WrappedException("RMS transaction error; could not back up original state of record; original operation [" + opType + "] aborted because transaction guarantees cannot be met (transaction is still open; you must roll back manually, if you wish)", e);
            }
        }
    }

    /* ========== DEBUGGING CODE ============ */

    public String debugInfo () {
        StringBuffer sb = new StringBuffer();
        sb.append("=================\n");

        String rmsBaseInfo;
        int numStores = -1;
        try {
            RMSStorageInfo info = getInfoRecord();
            rmsBaseInfo = info.numRecords + ":" + info.numDataStores + ":" + info.nextRecordID + "\n";
            numStores = info.numDataStores;
        } catch(RuntimeException re) {
            rmsBaseInfo = "info: corrupted\n";
        }
        Hashtable ix = index.getIndexTable();

        sb.append(basename + "(" + type.getName() + ") -- " + getStatus() + "\n");
        sb.append(rmsBaseInfo);

        sb.append("rec index:\n");
        for (Enumeration e = ix.keys(); e.hasMoreElements(); ) {
            int id = ((Integer)e.nextElement()).intValue();
            RMSRecordLoc loc = (RMSRecordLoc)ix.get(new Integer(id));
            sb.append("  " + id + " => (" + loc.rmsID + ", " + loc.recID + ")\n");
        }

        sb.append(printRMSInfo(index.getIndexStore().rms));

        for (int i = 0; i < numStores; i++) {
            sb.append(printRMSInfo(getDataStore(i).rms));
        }

        sb.append("\n");
        return sb.toString();
    }

    private String printRMSInfo (RecordStore rs) {
        StringBuffer sb = new StringBuffer();
        try {
            sb.append("RMS: " + rs.getName() + " [" + rs.getNumRecords() + "]\n");
            for (RecordEnumeration e = rs.enumerateRecords(null, null, false); e.hasNextElement(); ) {
                int id = e.nextRecordId();
                sb.append("  " + id + " => [" + rs.getRecordSize(id) + "]\n");
            }
        } catch (RecordStoreException e) {
            sb.append("RecordStoreException! " + e.getClass().getName() + " " + e.getMessage() + "\n");
        }
        return sb.toString();
    }

    public void getStatusReport(XmlSerializer o, String ns) throws StatusReportException, IOException {

        o.startTag(ns, "storage_utility");
        try {
        o.attribute(null, "name", this.getName());

        writeText(o, ns, "total_records", String.valueOf(getNumRecords()));

        writeText(o, ns, "total_size", String.valueOf(String.valueOf(getTotalSize())));

        String statusText;
        int statusFlag = getStatus();
        switch(statusFlag) {
            case STATUS_CLEAN: statusText = "CLEAN"; break;
            case STATUS_DIRTY: statusText = "DIRTY"; break;
            case STATUS_UNINITIALIZED: statusText = "UNINITIALIZED"; break;
            default: statusText = "UNKNOWN: " + statusFlag; break;
        }

        writeText(o, ns, "status_flag", statusText);

        RMSStorageInfo info = getInfoRecord();

        for (int i = 0; i < info.numDataStores; i++) {
            RMS rmsStore = getDataStore(i);

            o.startTag(ns, "rms_store");
            try {
                o.attribute(null, "name", rmsStore.name);
                o.attribute(null, "index", String.valueOf(i));

                try {
                    writeText(o, ns, "num_records", String.valueOf(rmsStore.rms.getNumRecords()));

                    writeText(o, ns, "size_used", String.valueOf(rmsStore.rms.getSize()));

                    writeText(o, ns, "size_available", String.valueOf(rmsStore.rms.getSizeAvailable()));
                } catch (RecordStoreNotOpenException e) {
                    throw new StatusReportException(e, "storage_utility","Storage: " + this.getName() + " Record Store Not Open");
                }
                rmsStore.close();
            }finally {
                o.endTag(ns, "rms_store");
            }
        }
        } finally {
            o.endTag(ns, "storage_utility");
        }
    }

    private void writeText(XmlSerializer serializer, String XMLNS, String element, String text) throws IllegalArgumentException, IllegalStateException, IOException {
        serializer.startTag(XMLNS,element);
        try {
            serializer.text(text == null ? "" : text);
        } catch(Exception e) {
            e.printStackTrace();
        } finally {
            serializer.endTag(XMLNS,element);
        }
    }

    public void log (String type, String message) {
        if (!basename.startsWith(LogEntry.STORAGE_KEY)) {
            Logger.log(type, basename + ": " + message);
        }
    }

    public void setReadOnly() {
        index.enterReadOnly();
    }
}

